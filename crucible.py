#!/usr/bin/env python3
"""
Crucible Protocol - Automated Test Execution Environment for CCC Stage 3

This module provides a secure, ephemeral, and completely isolated execution space
for automated verification of code generated by the Covenant Command Cycle.
"""

import os
import tempfile
import shutil
import subprocess
import logging

logger = logging.getLogger(__name__)


class CrucibleEnvironment:
    """
    The Crucible - A secure, ephemeral testing environment
    
    Each verification task creates a temporary directory, writes code and test files,
    executes tests in a sandboxed subprocess, and then atomizes the workspace.
    """
    
    def __init__(self):
        self.workspace = None
    
    def create_workspace(self):
        """Create a temporary workspace for code testing"""
        try:
            self.workspace = tempfile.mkdtemp(prefix="crucible_", suffix="_workspace")
            logger.info(f"[CRUCIBLE] Created workspace: {self.workspace}")
            return self.workspace
        except Exception as e:
            logger.error(f"[CRUCIBLE] Failed to create workspace: {e}")
            raise
    
    def write_file(self, filename, content):
        """Safely write content to a file within the workspace"""
        if not self.workspace:
            raise RuntimeError("Workspace not created. Call create_workspace() first.")
        
        file_path = os.path.join(self.workspace, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            logger.info(f"[CRUCIBLE] Written file: {filename}")
        except Exception as e:
            logger.error(f"[CRUCIBLE] Failed to write file {filename}: {e}")
            raise
    
    def run_tests(self, timeout=30):
        """
        Execute pytest in the workspace and capture results
        
        Args:
            timeout: Maximum time to wait for tests to complete (seconds)
            
        Returns:
            dict: {'returncode': int, 'stdout': str, 'stderr': str, 'success': bool}
        """
        if not self.workspace:
            raise RuntimeError("Workspace not created. Call create_workspace() first.")
        
        try:
            logger.info(f"[CRUCIBLE] Running tests in workspace: {self.workspace}")
            
            # Execute pytest with verbose output and capture all results
            result = subprocess.run(
                ['python', '-m', 'pytest', self.workspace, '-v', '--tb=short'],
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=self.workspace
            )
            
            success = result.returncode == 0
            
            logger.info(f"[CRUCIBLE] Test execution completed - Success: {success}")
            
            return {
                'returncode': result.returncode,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'success': success
            }
            
        except subprocess.TimeoutExpired:
            logger.error(f"[CRUCIBLE] Test execution timed out after {timeout} seconds")
            return {
                'returncode': -1,
                'stdout': '',
                'stderr': f'Test execution timed out after {timeout} seconds',
                'success': False
            }
        except Exception as e:
            logger.error(f"[CRUCIBLE] Test execution failed: {e}")
            return {
                'returncode': -1,
                'stdout': '',
                'stderr': str(e),
                'success': False
            }
    
    def cleanup_workspace(self):
        """Recursively delete the temporary workspace"""
        if self.workspace and os.path.exists(self.workspace):
            try:
                shutil.rmtree(self.workspace)
                logger.info(f"[CRUCIBLE] Workspace atomized: {self.workspace}")
                self.workspace = None
            except Exception as e:
                logger.error(f"[CRUCIBLE] Failed to cleanup workspace: {e}")
                raise
    
    def __enter__(self):
        """Context manager entry"""
        self.create_workspace()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit - always cleanup workspace"""
        self.cleanup_workspace()


def verify_code(code_to_test, test_code, timeout=30):
    """
    Convenience function to verify code with its test in an isolated environment
    
    Args:
        code_to_test: Python code to be tested
        test_code: pytest test code 
        timeout: Maximum time for test execution
        
    Returns:
        dict: Test execution results with success status
    """
    try:
        with CrucibleEnvironment() as crucible:
            # Write the main code file
            crucible.write_file('main.py', code_to_test)
            
            # Write the test file
            crucible.write_file('test_main.py', test_code)
            
            # Execute tests and return results
            return crucible.run_tests(timeout)
            
    except Exception as e:
        logger.error(f"[CRUCIBLE] Code verification failed: {e}")
        return {
            'returncode': -1,
            'stdout': '',
            'stderr': str(e),
            'success': False
        }